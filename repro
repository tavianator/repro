#!/usr/bin/env bash

set -eu

## Constants

# sysexits(3)
EX_USAGE=64
EX_DATAERR=65
EX_SOFTWARE=70
EX_CANTCREAT=73

# The current platform (kernel)
UNAME=$(uname)

## Command line parsing

_help() (
    _cmd=$(basename -- "$0")
    cat <<EOF
Usage: $_cmd [-d DIR] [-r RUNS] [-u USER] [-q] [-h] SCRIPT [ARGS...]

  -d DIR
      Set the directory for results and logs (default: ./results).  The current
      date and time will be appended to this path to distinguish runs.

  -r RUNS
      Run the benchmark this many times (default: 1).

  -u USER
      Run the benchmark as this user.  The default depends on the user who
      invoked $_cmd:

          user@host$ $_cmd ...      # default: user
          user@host$ sudo $_cmd ... # default: user
          root@host# $_cmd ...      # default: root

  -q
      Be quiet, don't show benchmark output.

  -h
      This help message.

  SCRIPT
      The benchmark script to invoke.

  ARGS
      Arguments to pass to the benchmark script.
EOF
)

_args=("$0" "$@")
_dir=./results
_runs=1
_user=
_quiet=
_bench=

while getopts 'd:r:u:qxh' opt; do
    case "$opt" in
        d)
            _dir="$OPTARG"
            ;;
        r)
            _runs="$OPTARG"
            ;;
        u)
            _user="$OPTARG"
            ;;
        q)
            _quiet=1
            ;;
        x)
            _bench=1
            ;;
        h)
            _help
            exit
            ;;
        *)
            _help >&2
            exit $EX_USAGE
            ;;
    esac
done

# The default user is the current user, before sudo if used
if [ -z "$_user" ] && [ -n "${SUDO_USER:-}" ]; then
    _user="$SUDO_USER"
fi

if ((OPTIND > $#)); then
    _help >&2
    exit $EX_USAGE
fi
_script="${!OPTIND}"
shift $OPTIND

## Utility functions

# Check if a command exists
is_command() {
    command -v "$1" >/dev/null
}

# Check if a function is defined
is_function() {
    test "$(type -t "$1")" = function
}

# Log a message
_log() {
    printf '%s: ' "$0"
    printf "$@"
    printf '\n'
}

# Exit with an error and message
_die() {
    _exit="$1"
    shift
    _log "$@" >&2
    exit "$_exit"
}

# Underline some text
_underline() {
    _str="$*"
    printf '%s\n' "$_str"
    printf '%*s\n\n' ${#_str} "" | tr ' ' '='
}

# Delineate an execution phase
_phase() {
    printf '\n'
    _underline "$(_log "$@")"
}

# Run a command as $_user
as_user() {
    if [ "$_user" ]; then
        sudo -Eu "$_user" -- "$@"
    else
        "$@"
    fi
}

# Redirect standard output/error to log files
_redirect() {
    _out="$1/stdout"
    _err="$1/stderr"
    shift

    # Don't make the logs owned by root
    as_user touch "$_out"
    as_user touch "$_err"

    if [ "$_quiet" ]; then
        "$@" >>"$_out" 2>>"$_err"
    else
        "$@" > >(tee -a "$_out") 2> >(tee -a "$_err" >&2)
    fi
}

_atexit_cmds=()

# Register a command to run when the script exits
atexit() {
    # Check if the EXIT trap is set, since atexit won't work otherwise
    trap -- KILL
    if trap -p EXIT | grep _run_atexit &>/dev/null; then
        _atexit_cmds+=("$(printf '%q ' "$@")")
    else
        _die $EX_SOFTWARE 'atexit used from subshell'
    fi
}

# Directory to store the atexit handlers' logs
_atexit_dir=

# Run the registered exit handlers
_run_atexit() {
    if [ "$_atexit_dir" ]; then
        _redirect "$_atexit_dir" exec
    fi

    # Run the handlers in the reverse order of installation
    while ((${#_atexit_cmds[@]} > 0)); do
        _cmd="${_atexit_cmds[-1]}"
        unset '_atexit_cmds[-1]'
        eval "$_cmd"
    done
}

trap _run_atexit EXIT

# Get a list of sysctls matching a glob pattern
get_sysctls() {
    for _ctl in $(sysctl -aN); do
        if [[ "$_ctl" == $1 ]]; then
            printf '%s\n' "$_ctl"
        fi
    done
}

# Set a sysctl for the duration of a benchmark
set_sysctl() {
    _prev=$(sysctl -n "$1")
    sysctl "$1=$2"
    atexit sysctl "$1=$_prev"
}

# Helper to write a string to a sysfs file
_sysfs() {
    printf '%s' "$3" >"$1"
    printf '%s: %s -> %s\n' "$1" "$2" "$3"
}

# Set a sysfs value for the duration of a benchmark
set_sysfs() {
    _prev=$(cat "$1")
    _sysfs "$1" "$_prev" "$2"
    atexit _sysfs "$1" "$2" "$_prev"
}

# Exit with an unsupported platform error
_idkhowto() {
    _die $EX_SOFTWARE "I don't know how to %s on %s" "$*" "$UNAME"
}

# Turn turbo boost off for the duration of a benchmark
turbo_off() {
    case "$UNAME" in
        Linux)
            _intel_turbo=/sys/devices/system/cpu/intel_pstate/no_turbo
            if [ -e "$_intel_turbo" ]; then
                set_sysfs "$_intel_turbo" 1
            else
                set_sysfs /sys/devices/system/cpu/cpufreq/boost 0
            fi
            ;;

        *)
            _idkhowto disable turbo boost
            ;;
    esac
}

# Turn off SMT for the duration of a benchmark
smt_off() {
    case "$UNAME" in
        Linux)
            set_sysfs /sys/devices/system/cpu/smt/control off
            return
            ;;

        FreeBSD)
            _threads=$(sysctl -n kern.smp.threads_per_core)
            if [ "$_threads" -eq 1 ]; then
                return
            fi
            ;;
    esac

    _idkhowto turn SMT off
}

# Set the CPU(s) to maximum frequency for a benchmark
cpu_freq_max() {
    case "$UNAME" in
        Linux)
            # Set the CPU governor to performance
            for _cpu in /sys/devices/system/cpu/cpu[0-9]*; do
                _online="$_cpu/online"
                if [ -e "$_online" ] && [ "$(cat "$_online")" != 1 ]; then
                    continue
                fi

                _governor="$_cpu/cpufreq/scaling_governor"
                if [ ! -e "$_governor" ]; then
                    continue
                fi
                set_sysfs "$_governor" performance
            done
            ;;

        FreeBSD)
            # Set the Intel Energy/Performance Preference to 0 (performance)
            # See intel_pstate(4)
            for _ctl in $(get_sysctls 'dev.hwpstate_intel.*.epp'); do
                set_sysctl "$_ctl" 0
            done
            ;;
    esac
}

## If we invoked ourselves with -x, directly run the script's bench() function

if [ "$_bench" ]; then
    source "$_script" "$@"
    bench "$@"
    exit $?
fi

## Set up the working directory

_dir="$_dir/$(date '+%Y/%m/%d/%T')"

if [ -e "$_dir" ]; then
    _die $EX_CANTCREAT '"%s" already exists' "$_dir"
fi

_init="$_dir/init"
_setup="$_dir/setup"
_teardown="$_dir/teardown"
as_user mkdir -p "$_init" "$_setup" "$_teardown"

## Describe this benchmarking run

_info() {
    _underline "$(printf '%s\n' "${_args[*]}")"

    printf 'uname: '
    uname -a
    printf 'uptime: '
    uptime
    printf 'cwd: %s\n' "$PWD"
    printf 'runs: %s\n' "$_runs"
    printf 'user: %s\n' "$_user"
    printf 'quiet: %s\n' "$_quiet"
    printf 'script: %s\n' "$_script"
}
_redirect "$_init" _info

as_user touch "$_init/env"
env >"$_init/env"

## Load and run the script

# Make the EXIT trap output to the teardown log
_atexit_dir=$(realpath "$_teardown")

_redirect "$_init" _phase 'Loading "%s" ...' "$_script"
_redirect "$_init" source "$_script" "$@"

if ! is_function bench; then
    _die $EX_DATAERR '%s does not define the function bench()' "$_script"
fi

if is_function setup; then
    export REPRO_DIR="$_setup"
    _redirect "$REPRO_DIR" _phase 'Running setup() ...'
    _redirect "$REPRO_DIR" setup "$@"
fi

for _run in $(seq -w "$_runs"); do
    _redirect "$REPRO_DIR" _phase 'Running bench(), iteration %s ...' "$_run"

    export REPRO_DIR="$_dir/runs/$_run"
    as_user mkdir -p "$REPRO_DIR"
    _redirect "$REPRO_DIR" as_user "$0" -x -- "$_script" "$@"
done

_redirect "$_teardown" _phase 'Tearing down ...'
